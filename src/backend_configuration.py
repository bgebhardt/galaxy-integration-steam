import configparser
import enum
import os
import pathlib
import platform
from textwrap import dedent
from typing import Optional


system = platform.system()
if system == "Windows":
    _PLUGINS_DIR = os.path.expandvars("%LOCALAPPDATA%/GOG.com/Galaxy/plugins/installed")
elif system == "Darwin":
    _PLUGINS_DIR = os.path.expanduser(
        "~/Library/Application Support/GOG.com/Galaxy/plugins/installed"
    )
else:
    raise RuntimeError(f"Not supported os: {system}")

_USER_CONFIG_NAME = "steam_plugin_config.ini"
USER_CONFIG_LOCATION = pathlib.Path(_PLUGINS_DIR) / _USER_CONFIG_NAME

_NULL_VALUE = "none"


class ConfigParseError(configparser.ParsingError):
    pass


class BackendMode(enum.Enum):
    PublicProfiles = "public_profiles"
    SteamNetwork = "steam_network"


class BackendConfiguration(configparser.ConfigParser):
    _MODE_SECTION = "BackendMode"
    _CURRENT = "initial"
    _FALLBACK = "fallback"

    _CONFIG_SPEC = {
        _MODE_SECTION: {
            _CURRENT: tuple(m.value for m in BackendMode),
            _FALLBACK: (_NULL_VALUE,) + tuple(m.value for m in BackendMode),
        },
    }
    _DEFAULT_CONFIG = {
        _MODE_SECTION: {
            _CURRENT: BackendMode.SteamNetwork.value,
            _FALLBACK: BackendMode.PublicProfiles.value,
        }
    }
    _HEADER_END_MARKER = "; === END OF AUTOGENERATED PART ===\n"
    _INFO_HEADER = (
        dedent(
            """\
            ; === START OF AUTOGENERATED PART ===
            ;
            ; PLEASE NOTE:
            ;
            ; Any changes made to this AUTOGENERATED PART of the file will be automatically RESET to default.
            ; Please make your changes BELOW THE AUTOGENERATED PART, or they WILL be overwritten!
            ;
            ;
            ; DESCRIPTION:
            ;
            ; This file contains configuration values used for setting an initial way and a fallback way to communicate with Steam. 
            ; These ways of communication are internally referred to as `backends`.
            ; The initial backend is loaded each time the plugin starts. If authentication fails, the backend is switched to the fallback one.
            ;
            ; More information about currently supported backends is available in the README of the Steam plugin project.
            ; 
            ; 
            ; STRUCTURE:
            ; 
            ; [BackendMode] - a group of settings related to the way the plugin communicates with Steam
            ; initial - the operation mode in which the plugin starts; default: steam_network; possible values: steam_network, public_profiles
            ; fallback - the operation mode to switch to in case of failure in the initial mode; default: public_profiles; possible values: steam_network, public_profiles, none
            ;
            ;
            ; EXAMPLE:
            ;
            ; [BackendMode]     
            ; initial = steam_network
            ; fallback = public_profiles
            ;
            """
        ) + _HEADER_END_MARKER
    )
    
    def __init__(self):
        super().__init__()
        self.read_dict(self._DEFAULT_CONFIG, source="<defaults from dict>")

    def read_strict(self, *args, **kwargs):
        try:
            self.read(*args, **kwargs)
        except configparser.ParsingError as e:
            raise ConfigParseError(e)
        self._validate_config(self._CONFIG_SPEC)

    def _validate_config(self, spec: dict):
        for section in self.sections():
            if section not in spec.keys():
                raise ConfigParseError(f"Unrecognized section {section}.")

        for section, keys in spec.items():
            if section not in self:
                raise ConfigParseError(f"Missing section {section}.")

            for key, values in keys.items():
                if self[section].get(key) not in values:
                    raise ConfigParseError(
                        f"Invalid value for {key} under section {section}.\n"
                        f"Expected: {values}, got: {self[section].get(key)}"
                    )

    @classmethod
    def _config_content_without_header(cls, initial_content: str) -> str:
        end_marker_idx = initial_content.find(cls._HEADER_END_MARKER)
        if end_marker_idx == -1:
            content_idx = 0
        else:
            content_idx = end_marker_idx + len(cls._HEADER_END_MARKER)
        return initial_content[content_idx:]

    @classmethod
    def regenerate_user_config(cls, config_path: pathlib.Path):
        config_path.touch(exist_ok=True)
        with open(config_path) as f:
            initial_content = f.read()

        new_content = cls._config_content_without_header(initial_content)
        with open(config_path, "w") as f:
            f.write(cls._INFO_HEADER)
            f.write(new_content)

    @property
    def initial_mode(self) -> BackendMode:
        return BackendMode(self[self._MODE_SECTION][self._CURRENT])

    @property
    def fallback_mode(self) -> Optional[BackendMode]:
        mode = self[self._MODE_SECTION][self._FALLBACK]
        if mode == _NULL_VALUE:
            return None
        return BackendMode(mode)
